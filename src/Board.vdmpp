class Board

-- Position is a pair of coordenates
types
		public Position:: x:nat  y:nat;
		public PType = <BOMB> | <MARSHALL> | <GENERAL> | <COLONEL> | <MAJOR> | <CAPTAIN> | <LIEUTENANT> | <SERGEANT> | <MINER> | <SCOUT> | <SPY> | <FLAG>;
values
-- TODO Define values here
		private max_coord : nat = 9;
instance variables

	private board : map Position to Cell := {|->};
-- TODO Define instance variables here
operations
-- TODO Define operations here

		public Board : () ==> Board
  	Board() ==
  	(
  		for i = 0 to max_coord by 1 do
  		(
  			for j = 0 to max_coord by 1 do
  			(
  				 board := board ++ {mk_Position(i,j)|-> new Cell(i,j)};
  			)
  		)
		);

  public pure validCoords : Position ==> bool
  validCoords(position) ==
  (
  	return position.x <= max_coord and position.y <= max_coord;
  );
  
  public pure freeSpace : Position ==> bool
  freeSpace(position) == 
  (
  	return not board(position).isOccupied();
  )
  pre validCoords(position);
  
  public pure hasPiece : Position ==> bool
  hasPiece(position) == return board(position).getPiece() <> nil;
  
  public placePiece : nat*nat*Piece`PType*Piece`PColor ==> ()
  placePiece(i,j,type,color) == 
  (
  	dcl piece : Piece := new Piece(type,color);
  	board(mk_Position(i,j)).setPiece(piece);
  )
  pre freeSpace(mk_Position(i,j)) and colorRegion(mk_Position(i,j),color);
  
  
  -- responsible for making a move
  public makeMove : Position*Position*Piece`PColor ==> bool
  makeMove(origin,destination,color) == 
  (
  	dcl pieceOrigin : [Piece] := board(origin).getPiece();
  	dcl pieceDestination : [Piece] := board(destination).getPiece();
  	
  	
  	if movePossible(origin,destination,pieceOrigin.hasUnlimitedRange())
  	then (
	  	if pieceDestination = nil --move Piece
	  		then (
	  				board(origin).removePiece();
	  				board(destination).setPiece(pieceOrigin);
	  				return true;
	  			)
	  			else ( 
	  				if pieceOrigin.getType() = pieceDestination.getType()
	  					then (
	  						board(origin).removePiece();
	  						board(destination).removePiece();
	  						return true;
	  					)
	  					else (
	  					 if getInteraction(pieceOrigin,pieceDestination)
			  				then (
		  						board(origin).removePiece();
		  						board(destination).setPiece(pieceOrigin);
		  						return true;
		  					)
		  					else (
		  						board(origin).removePiece();
		  						return true;
		  					)
		  				)
	  			)
  	);
  	return false;
  )pre validCoords(origin) and validCoords(destination) and hasPiece(origin) and board(origin).getPiece().getColor() = color;
  
	--true if it eats the second piece, false if the second piece its stronger
  public pure getInteraction : Piece * Piece ==> bool
	getInteraction(origin,destination) == (
		dcl originType : PType := origin.getType();
		dcl destinationType : PType := destination.getType();
		cases originType :
		<MINER> -> return destinationType = <BOMB>,
		<SPY> -> return destinationType = <MARSHALL>,
		others -> strongerPiece(originType,destinationType)
		end
	);
	
	
	public pure movePossible : Position*Position*bool ==> bool
	movePossible(origin,destination,range) == 
	(
		if range
			then return isFreeLane(origin,destination)
			else if origin.x = destination.x
				then return abs(origin.y - destination.y) = 1
				else return abs(origin.x - destination.x) = 1;
	) 
	pre origin.x = destination.x or origin.y =destination.y;
	
	--TODO todo
	public pure isFreeLane : Position*Position ==> bool
	isFreeLane(origin,destination) == 
	(
		if origin.x = destination.x 
			then
				for i = origin.y to destination.y by (if origin.y >= destination.y then -1 else 1) do
					(if i <> destination.y then if board(mk_Position(destination.x,i)).isOccupied() then return false;)
			else 
				for i = origin.x to destination.x by (if origin.x >= destination.x then -1 else 1) do
					(if i <> destination.y then if board(mk_Position(i,destination.y)).isOccupied() then return false;);
					
			return true;
	);
  
functions
-- TODO Define functiones here
	--get index of type of piece
	public getIndex : PType -> nat
	getIndex(type) ==
	(
		[i | i in set inds Stratego`TYPES_OF_PIECES & Stratego`TYPES_OF_PIECES(i) = type](1)
	);
	
	public strongerPiece : PType*PType -> bool
	strongerPiece(originType,destinationType) == (
		 getIndex(originType) > getIndex(destinationType)
	);
	
	public colorRegion : Position*Piece`PColor -> bool
	colorRegion(position, color) ==
		if color = <BLUE> then position.y < 4 else position.y > 5;

	
traces
-- TODO Define Combinatorial Test Traces here
end Board