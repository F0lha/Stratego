class Board

-- Position is a pair of coordenates
types
		public Position:: x:nat  y:nat;
values
-- TODO Define values here
		private max_coord : nat = 9;
instance variables

	private board : map Position to Cell := {|->};
-- TODO Define instance variables here
operations
-- TODO Define operations here

		public Board : () ==> Board
  	Board() ==
  	(
  		for i = 0 to max_coord by 1 do
  		(
  			for j = 0 to max_coord by 1 do
  			(
  				 board := board ++ {mk_Position(i,j)|-> new Cell(i,j)};
  			)
  		)
		);

  public pure validCoords : Position ==> bool
  validCoords(position) ==
  (
  	return position.x <= max_coord and position.y <= max_coord;
  );
  
  public pure freeSpace : Position ==> bool
  freeSpace(position) == 
  (
  	return not getCell(position).isOccupied();
  )
  pre validCoords(position);
  
  public pure hasPiece : Position ==> bool
  hasPiece(position) == 
  (
  return getPiece(position) <> nil
  )
	pre validCoords(position);
  
  public pure getCell : Position ==> [Cell]
  getCell(position) == 
  (
  return board(position)
  )
  pre validCoords(position);
  
  public pure getPiece : Position ==> [Piece]
  getPiece(position) == 
  (
  return getCell(position).getPiece()
  )
  pre validCoords(position);
  
  public placePiece : nat*nat*Piece`PType*Piece`PColor ==> ()
  placePiece(i,j,type,color) == 
  (
  	dcl piece : Piece := new Piece(type,color);
  	board(mk_Position(i,j)).setPiece(piece);
  )
  pre freeSpace(mk_Position(i,j)) and colorRegion(mk_Position(i,j),color) and limitPieces(type,color)
  post hasPiece(mk_Position(i,j));
  
  
  -- responsible for making a move
  public makeMove : Position*Position*Piece`PColor ==> bool
  makeMove(origin,destination,color) == 
  (
  	dcl pieceOrigin : [Piece] := getPiece(origin);
  	dcl pieceDestination : [Piece] := getPiece(destination);
  	
  	
  	if movePossible(origin,destination,pieceOrigin.hasUnlimitedRange())
  	then (
	  	if pieceDestination = nil --move Piece
	  		then (
	  				board(origin).removePiece();
	  				board(destination).setPiece(pieceOrigin);
	  				return true;
	  			)
	  			else (
	  				if  pieceOrigin.getColor() = pieceDestination.getColor() 
	  					then return false
	  				else (
		  				if pieceOrigin.getType() = pieceDestination.getType()
		  					then (
		  						board(origin).removePiece();
		  						board(destination).removePiece();
		  						return true;
		  					)
		  					else (
		  					 if getInteraction(pieceOrigin,pieceDestination)
				  				then (
			  						board(origin).removePiece();
			  						board(destination).removePiece();
			  						board(destination).setPiece(pieceOrigin);
			  						return true;
			  					)
			  					else (
			  						board(origin).removePiece();
			  						return true;
			  					)
			  				)
		  			)
		  		)
  	)else return false;
  )pre validCoords(origin) and validCoords(destination) and hasPiece(origin) and getPiece(origin).getColor() = color and getPiece(origin).canMove();
  
	--true if it eats the second piece, false if the second piece its stronger
  public pure getInteraction : Piece * Piece ==> bool
	getInteraction(origin,destination) == (
		dcl originType : Piece`PType := origin.getType();
		dcl destinationType : Piece`PType := destination.getType();
		cases originType :
		<MINER> -> return destinationType = <BOMB>,
		<SPY> -> return destinationType = <MARSHALL>,
		others -> strongerPiece(originType,destinationType)
		end
	);
	
	public pure limitPieces : Piece`PType*Piece`PColor ==> bool
	limitPieces(type,color) == 
	(
		dcl pieces : nat := 0;
		
		for all cell in set rng board do 
			(if cell.getPiece() <> nil 
				then 
					(if (cell.getPiece().getType() = type and cell.getPiece().getColor() = color) 
						then pieces := pieces + 1));
		
		return pieces < Stratego`PIECES_PER_PLAYER(getIndex(type));
	) pre type in set elems Stratego`TYPEOFPIECES;
	
	public pure movePossible : Position*Position*bool ==> bool
	movePossible(origin,destination,range) == 
	(
		if range
			then return isFreeLane(origin,destination)
			else if origin.x = destination.x
				then return abs(origin.y - destination.y) = 1
				else return abs(origin.x - destination.x) = 1;
	) 
	pre origin.x = destination.x or origin.y =destination.y;
	
	
	public pure isFreeLane : Position*Position ==> bool
	isFreeLane(origin,destination) == 
	(
		if origin.x = destination.x 
			then
				for i = origin.y to destination.y by (if origin.y >= destination.y then -1 else 1) do
					(if (i <> destination.y and i <> origin.y) then if getCell(mk_Position(destination.x,i)).isOccupied() then return false;)
			else 
				for i = origin.x to destination.x by (if origin.x >= destination.x then -1 else 1) do
					(if (i <> destination.x and i <> origin.x) then if getCell(mk_Position(i,destination.y)).isOccupied() then return false;);
					
			return true;
	)pre validCoords(origin) and validCoords(destination);
	
	public pure checkGameOver : () ==> [Piece`PColor]
	checkGameOver() == 
	(
		dcl flagBlue : [Piece] := nil;
		dcl flagRed : [Piece] := nil;
		for all cell in set rng board do 
			if cell.getPiece() <> nil 
				then 
						if cell.getPiece().getType() = <FLAG> 
							then
								if cell.getPiece().getColor() = <BLUE>
									then flagBlue := cell.getPiece()
								else 
									if cell.getPiece().getColor() = <RED> 
										then flagRed := cell.getPiece();
										
		if flagBlue	<> nil and flagRed <> nil then return nil;			
		if flagBlue	= nil and flagRed = nil then return nil;					
		if flagBlue	= nil then return flagRed.getColor() else return flagBlue.getColor();
	);
  
functions
-- TODO Define functiones here
	--get index of type of piece
	public getIndex : Piece`PType -> nat
	getIndex(type) ==
	(
		[i | i in set inds Stratego`TYPEOFPIECES & Stratego`TYPEOFPIECES(i) = type](1)
	) pre type in set elems Stratego`TYPEOFPIECES;
	
	public strongerPiece : Piece`PType*Piece`PType -> bool
	strongerPiece(originType,destinationType) == (
		 getIndex(originType) < getIndex(destinationType)
	) pre originType in set elems Stratego`TYPEOFPIECES and destinationType in set elems Stratego`TYPEOFPIECES;
	
	public colorRegion : Position*Piece`PColor -> bool
	colorRegion(position, color) ==
		if color = <BLUE> then position.y < 4 else position.y > 5;

	
traces
-- TODO Define Combinatorial Test Traces here
end Board